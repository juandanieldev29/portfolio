---
import Section from "./Section.astro";
import { Image } from "astro:assets";
import type { AboutProps, HeroProps } from "@types";

type Props = AboutProps & Pick<HeroProps, "name">;

const { description, image, name } = Astro.props;
---

<Section text="About Me" href="about">
  <div class="flex flex-col items-center gap-12 md:flex-row md:gap-8">
    <p class="reveal fade-up duration-2 delay-2 w-auto text-base text-neutral md:pr-5">{description}</p>
    <div
      class="reveal fade-up duration-2 delay-2 h-80 w-64 flex-shrink-0 rotate-[5deg] bg-white p-4 md:rotate-[7deg]"
    >
      <Image
        class="object-cover reveal fade-up duration-2 delay-2"
        src={image}
        width="260"
        height="260"
        alt={name}
      />
    </div>
  </div>
</Section>

<script type="module" client:idle>
  (() => {
    const revealEls = () => {
      const section = document.getElementById('about');
      if (!section) return [];
      return Array.from(section.querySelectorAll('.reveal'));
    };

    const createObserverForReveals = () => {
      const els = revealEls();
      if (!els.length) return null;

      // Exclude the main description paragraph and the primary
      // reveal items (the direct children reveals such as the image wrapper)
      // so those can be revealed together when the section reaches 40%.
      const section = document.getElementById('about');
      const desc = section ? section.querySelector('p.reveal') : null;
      const inner = section ? section.querySelector('div') : null;
      const primaryReveals = inner ? Array.from(inner.querySelectorAll(':scope > .reveal')) : [];
      const excludes = [desc, ...primaryReveals].filter(Boolean);
      const toObserve = els.filter(el => !excludes.includes(el));

      // Use 20vh offset to give a consistent intersection zone across viewports
      const vhOffsetPx = Math.round(window.innerHeight * 0.2);
      const rootMargin = `0px 0px -${vhOffsetPx}px 0px`;

      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('is-visible');
            obs.unobserve(entry.target);
          }
        });
      }, { threshold: 0, rootMargin });

      toObserve.forEach((el) => observer.observe(el));
      return observer;
    };

    // Start reveal logic when 40% of the #about section is visible.
    // This triggers the description to become visible immediately
    // and then starts observing the remaining .reveal elements inside
    // the section.
    const startWhenAbout40Visible = () => {
      const section = document.getElementById('about');
      if (!section) {
        // Fallback: start immediately if section not found
        createObserverForReveals();
        return;
      }

      const desc = section.querySelector('p.reveal');
      const inner = section.querySelector('div');
      const primaryReveals = inner ? Array.from(inner.querySelectorAll(':scope > .reveal')) : [];

      const sectionObserver = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.intersectionRatio >= 0.4) {
            // Reveal the description and primary items immediately (if present)
            if (desc) desc.classList.add('is-visible');
            primaryReveals.forEach(el => el.classList.add('is-visible'));
            // Start observing the remaining reveals inside the section
            createObserverForReveals();
            obs.disconnect();
          }
        });
      }, { threshold: [0.4] });

      sectionObserver.observe(section);
    };

    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(startWhenAbout40Visible);
    } else {
      setTimeout(startWhenAbout40Visible, 200);
    }
  })();
</script>
